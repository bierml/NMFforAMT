# -*- coding: utf-8 -*-
"""Music Transcribing[NMF].ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qYgOYpoLSC6k3a3LFJ6RYwmigui9tFDB

Библиотеки которые можно использовать: librosa, NMFToolbox, Nimfa, Mido/Pretty_midi,MIDIUtil.

Из всех библиотек с реализацией NMF пока остановился на Nimfa, не пойдет с ней - буду пробовать работать с NMFToolbox. Перед тем как запускать код дальше надо установить Nimfa.
"""

pip install nimfa

"""**Читаем исходный файл**"""

from scipy.io import wavfile
import numpy as np
import librosa
import nimfa
gamma = 100
f_s, x = wavfile.read("/content/FChopinPreludeOp28n4.wav")
print(f_s)        # sample rate
print(x.dtype)   # int16, int32, etc.
print(x.shape)   # (N,) mono or (N, channels)
print(x[100000])
'''def init_nmf_template_pitch(K, pitch_set, freq_res, tol_pitch=0.05):
    """Initializes template matrix for a given set of pitches

    Notebook: C8/C8S3_NMFSpecFac.ipynb

    Args:
        K (int): Number of frequency points
        pitch_set (np.ndarray): Set of fundamental pitches
        freq_res (float): Frequency resolution
        tol_pitch (float): Relative frequency tolerance for the harmonics (Default value = 0.05)

    Returns:
        W (np.ndarray): Nonnegative matrix of size K x R with R = len(pitch_set)
    """
    R = len(pitch_set)
    W = np.zeros((K, R))
    for r in range(R):
        W[:, r] = template_pitch(K, pitch_set[r], freq_res, tol_pitch=tol_pitch)
    return W'''
def init_nmf_template_pitch_onset(K, pitch_set, freq_res, tol_pitch=0.05):
    """Initializes template matrix with onsets for a given set of pitches

    Notebook: C8/C8S3_NMFSpecFac.ipynb

    Args:
        K (int): Number of frequency points
        pitch_set (np.ndarray): Set of fundamental pitches
        freq_res (float): Frequency resolution
        tol_pitch (float): Relative frequency tolerance for the harmonics (Default value = 0.05)

    Returns:
        W (np.ndarray): Nonnegative matrix of size K x (2R) with R = len(pitch_set)
    """
    R = len(pitch_set)
    W = np.zeros((K, 2*R))
    for r in range(R):
        W[:, 2*r] = 0.1
        W[:, 2*r+1] = template_pitch(K, pitch_set[r], freq_res, tol_pitch=tol_pitch)
    return W
def template_pitch(K, pitch, freq_res, tol_pitch=0.05):
    """Defines spectral template for a given pitch

    Notebook: C8/C8S3_NMFSpecFac.ipynb

    Args:
        K (int): Number of frequency points
        pitch (float): Fundamental pitch
        freq_res (float): Frequency resolution
        tol_pitch (float): Relative frequency tolerance for the harmonics (Default value = 0.05)

    Returns:
        template (np.ndarray): Nonnegative template vector of size K
    """
    max_freq = K * freq_res
    pitch_freq = 2**((pitch - 69) / 12) * 440
    max_order = int(np.ceil(max_freq / ((1 - tol_pitch) * pitch_freq)))
    #print(max_freq,pitch_freq,max_order)
    template = np.zeros(K)
    for m in range(1, max_order + 1):
        min_idx = max(0, int((1 - tol_pitch) * m * pitch_freq / freq_res))
        max_idx = min(K-1, int((1 + tol_pitch) * m * pitch_freq / freq_res))
        template[min_idx:max_idx+1] = 1 / m
    return template
'''def pitch(p):
  return 2**((p-69)/12) * 440
def interval(freq, cents=20):
  return (freq * 2 ** (-cents/1200), freq * 2 ** (cents/1200))'''
if(x.dtype==np.int32):
  x = x / (2**31)
elif(x.dtype==np.int16):
  x = x / (2**15)
else:
  raise ValueError(f"Unsupported sample type: {x.dtype}")
spectrogram = np.abs(librosa.stft(x, n_fft=2048,hop_length=1024))
spectrogram_compressed = np.log(1+gamma*spectrogram)
print(x[100000])
print(np.min(spectrogram_compressed),np.max(spectrogram_compressed))
print(spectrogram_compressed.shape)
pitches = [x+21 for x in range(88)]
freq_res = f_s/(2 * 1025)
print(freq_res)
W_temp = init_nmf_template_pitch_onset(1025,pitches,freq_res)
H_temp = np.random.rand(88*2, spectrogram_compressed.shape[1])
#nmf = nimfa.Nmf(spectrogram_compressed, seed='fixed', W=W_temp)
nmf = nimfa.Nmf(
    spectrogram_compressed,
    rank=88*2,
    seed='fixed',
    W=W_temp,
    H=H_temp,
    max_iter=200,
    beta=1, sparsity=(None, 0.2)
)
nmf_fit = nmf()
W_est = nmf_fit.basis()
H_est = nmf_fit.coef()

m = template_pitch(K=1025,pitch=69,freq_res=1)
print(type(m))
print(np.max(m))

pitches = [x+21 for x in range(88)]
print(pitches)

!grep -rl "np.mat" /usr/local/lib/python3.12/dist-packages/nimfa | xargs sed -i 's/np.mat/np.asmatrix/g'

!grep -rl "asmatrixrix" /usr/local/lib/python3.12/dist-packages/nimfa | xargs sed -i 's/asmatrixrix/asmatrix/g'

!grep -R "asmatrixrix" /usr/local/lib/python3.12/dist-packages/nimfa

#print(W_est.shape)
#print(H_est[:,100])
import matplotlib.pyplot as plt
#H_est_visualisation = np.log(1+10*H_est)
from scipy.signal import butter, filtfilt

b, a = butter(2, 0.1)   # low-pass along time
#H_est_visualisation = filtfilt(b, a, H_est, axis=1)
#H_est_visualisation = np.log(1+10*H_est[1::2,:])
#H_est_visualisation = filtfilt(b, a, H_est_visualisation, axis=1)
plt.figure()
plt.imshow(H_est, aspect='auto', origin='lower')
plt.colorbar()
plt.title("Activation matrix H")
plt.xlabel("Time frames")
plt.ylabel("Pitch / Component index")
plt.show()

import numpy as np
from scipy.signal import medfilt
from scipy.ndimage import gaussian_filter1d, binary_opening, binary_closing, label
from scipy.ndimage import generate_binary_structure

def mad(a):
    """Median absolute deviation (robust scale)."""
    m = np.median(a)
    return np.median(np.abs(a - m))

def track_notes_fixed(H,
                      sr=None, hop_length=None,
                      sigma_t=2.5,        # frames: temporal smoothing
                      sigma_p=0.8,        # pitches: pitch-axis smoothing
                      per_pitch_k=1.2,    # threshold factor (uses MAD)
                      med_kernel=(3, 17), # (pitch, time) odd sizes
                      morph_iterations_open=1,
                      morph_iterations_close=1,
                      min_dur_s=0.08,
                      merge_gap_s=0.03):
    """
    Robust note tracker for activation matrix H (K x T).
    Returns:
      piano_roll: binary K x T
      notes: list of dicts {'pitch_idx','onset','offset','score'}
    """
    Hf = H.astype(float).copy()
    K, T = Hf.shape

    # --- 1) smoothing (gaussian) ------------------------------------------------
    if sigma_t > 0:
        Hf = gaussian_filter1d(Hf, sigma=sigma_t, axis=1, mode='reflect')
    if sigma_p > 0:
        Hf = gaussian_filter1d(Hf, sigma=sigma_p, axis=0, mode='reflect')

    # --- 2) per-pitch robust threshold (median + k * MAD) -----------------------
    # compute median and MAD per pitch (row)
    medians = np.median(Hf, axis=1)
    mads = np.array([mad(Hf[i]) for i in range(K)])
    # avoid zero MAD
    mads[mads == 0] = np.std(Hf, axis=1)[mads == 0] + 1e-12
    thr = medians + per_pitch_k * mads
    Hbin = (Hf > thr[:, None])

    # --- 3) 2D median filter: ensure odd kernel sizes ---------------------------
    pk, tk = med_kernel
    if pk % 2 == 0: pk += 1
    if tk % 2 == 0: tk += 1
    Hbin = medfilt(Hbin.astype(np.uint8), kernel_size=(pk, tk)).astype(bool)

    # --- 4) morphological opening/closing (boolean + explicit struct) ----------
    # use a small 2D structure to allow connectivity in pitch and time
    struct = generate_binary_structure(2, 1)  # 3x3 connectivity kernel
    # expand the struct to desired shape by convolving (approx) via ones
    # here we'll build a rectangular structure shape (p_pitch x p_time)
    p_struct = (3, max(3, tk//3))
    struct_rect = np.ones(p_struct, dtype=bool)
    for _ in range(morph_iterations_open):
        Hbin = binary_opening(Hbin, structure=struct_rect)
    for _ in range(morph_iterations_close):
        Hbin = binary_closing(Hbin, structure=struct_rect)

    # --- 5) label 2D connected components and extract note events ---------------
    labeled, ncomp = label(Hbin, structure=struct_rect)
    piano_roll = np.zeros_like(Hbin, dtype=np.uint8)
    notes = []

    # helper conversions
    if sr is not None and hop_length is not None:
        frames_to_seconds = lambda f: f * hop_length / sr
        seconds_to_frames = lambda s: int(round(s * sr / hop_length))
    else:
        frames_to_seconds = lambda f: f  # identity if unknown
        seconds_to_frames = lambda s: int(round(s))

    min_dur_frames = max(1, seconds_to_frames(min_dur_s))
    merge_gap_frames = seconds_to_frames(merge_gap_s)

    for comp_id in range(1, ncomp + 1):
        ys, xs = np.where(labeled == comp_id)  # ys = pitch indices, xs = time indices
        if xs.size == 0:
            continue
        onset = xs.min()
        offset = xs.max()
        dur = offset - onset + 1
        if dur < min_dur_frames:
            continue

        # compute representative pitch: weighted by Hf (mean energy per pitch)
        pitch_means = [Hf[y, xs].mean() for y in np.unique(ys)]
        unique_pitches = np.unique(ys)
        best_pitch_idx = unique_pitches[int(np.argmax(pitch_means))]
        score = float(Hf[best_pitch_idx, onset:offset+1].mean())

        # fill piano roll for this pitch and interval (clamp to bounds)
        piano_roll[best_pitch_idx, onset:offset+1] = 1

        notes.append({
            'pitch_idx': int(best_pitch_idx),
            'onset': int(onset),
            'offset': int(offset),
            'score': score
        })

    # --- 6) merge close events of the same pitch --------------------------------
    notes_sorted = sorted(notes, key=lambda n: (n['pitch_idx'], n['onset']))
    merged = []
    for n in notes_sorted:
        if not merged or merged[-1]['pitch_idx'] != n['pitch_idx']:
            merged.append(n.copy())
            continue
        prev = merged[-1]
        if n['onset'] - prev['offset'] <= merge_gap_frames:
            prev['offset'] = max(prev['offset'], n['offset'])
            prev['score'] = max(prev['score'], n['score'])
        else:
            merged.append(n.copy())
    notes = merged

    # rebuild piano_roll from merged notes
    piano_roll = np.zeros_like(piano_roll)
    for n in notes:
        piano_roll[n['pitch_idx'], n['onset']:n['offset']+1] = 1

    return piano_roll, notes, Hf, thr  # return Hf and thr for debugging/visualization
#H_est_vis = note_tracking(H_est_visualisation)
res = track_notes(H_est[1::2])
#print(res[0].shape)
#H_est_vis = note_tracking_simple(H_est)
plt.figure()
#plt.imshow(H_est[1::2,],aspect='auto', origin='lower')
plt.imshow(res[0],aspect='auto', origin='lower')
plt.colorbar()
plt.title("Activation matrix H")
plt.xlabel("Time frames")
plt.ylabel("Pitch / Component index")
plt.show()

tempo, beats = librosa.beat.beat_track(y=x, sr=f_s)

tempo = float(tempo)          # or: tempo = tempo.item()

print(f"Estimated tempo: {tempo:.2f} BPM")

beat_times = librosa.frames_to_time(beats, sr=f_s)
print(f"Beat positions (sec.): {beat_times}")

plt.imshow(
    gaussian_filter1d(H_est[1::2,], sigma=2.5, axis=1),
    aspect='auto', origin='lower'
)
plt.title("Smoothed H (time)")